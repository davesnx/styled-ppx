---
alwaysApply: false
---
# cx2 Pipeline - Static CSS Extraction

This document explains how `[%cx2]` worksâ€”the statically extracted CSS path. Unlike `[%cx]` which generates runtime CSS-in-JS code, `[%cx2]` extracts CSS at compile-time into a separate `.css` file with zero runtime CSS generation overhead.

## Overview

```reason
let css = color => [%cx2 "display: flex; color: $(color)"];
```

Gets transformed into:

```reason
[@css ".css-17vxl0k { display: flex; }\n.css-3tpy8b { color: var(--var-19ja411); }\n"]
let css = color => CSS.make(
  "css-17vxl0k css-3tpy8b",
  [("--var-19ja411", CSS.Types.Color.toString(color))]
);
```

The key differences from `[%cx]`:
1. **Atomic CSS** - Each declaration gets its own className (e.g., `css-17vxl0k` for `display: flex`)
2. **CSS Custom Properties** - Interpolations become `var(--var-xxxx)` references
3. **Static Extraction** - CSS is collected into a `[@css ...]` attribute, later extracted to a `.css` file
4. **Runtime Type Coercion** - `CSS.Types.X.toString` converts typed values to strings at runtime

## Pipeline Stages

### Stage 1: Parsing (`Styled_ppx_css_parser.Driver`)

The CSS string is parsed by `Styled_ppx_css_parser.Driver.parse_declaration_list`.

```reason
[%cx2 "display: flex; color: $(myColor)"]
```

Produces an AST (`Styled_ppx_css_parser.Ast.rule_list`) representing:
- Declaration: `display: flex`
- Declaration: `color: $(myColor)` (where `$(myColor)` is a `Variable` node)

Key files:
- `packages/css-parser/lib/Parser.mly` - Menhir grammar
- `packages/css-parser/lib/Lexer.re` - Lexer with `INTERPOLATION` token support
- `packages/css-parser/lib/Ast.re` - AST types including `Variable(list(string))`

### Stage 2: Type Checking (`ppx.re`)

Before extraction, `[%cx2]` validates all properties against the CSS spec using `type_check_rule_list`:

```reason
let validations = type_check_rule_list(rule_list);
switch (get_errors(validations)) {
| [] => /* proceed with extraction */
| errors => /* report type errors */
}
```

Type checking uses `Css_grammar.Parser.check_property(~loc, ~name, value)` which:
1. Finds the property's grammar rule via `find_property(name)`
2. Parses the value against the rule
3. Falls back to universal rules (interpolation, CSS-wide keywords, `var()`)

This ensures invalid CSS like `display: banana` is caught at compile-time.

### Stage 3: CSS Transformation (`Css_file.push`)

The parsed AST goes through `Css_file.push` which orchestrates the transformation:

```reason
let (classNames, dynamic_vars) = Css_file.push(rule_list);
```

#### 3.1. Atomization (`Css_transform.atomize_rules`)

Each declaration becomes its own atomic rule with a content-hashed className:

```css
/* Input */
display: flex; color: red;

/* Output - two separate rules */
.css-17vxl0k { display: flex; }
.css-3tpy8b { color: red; }
```

The className is generated via `Murmur2.default(css_content)` ensuring identical declarations share the same className across the codebase.

Implementation in `Css_file.re`:
```reason
let generate_class_from_content = (content: string): string => {
  Printf.sprintf("css-%s", Murmur2.default(content));
};
```

#### 3.2. Variable Transformation (`transform_component_value`)

Interpolations (`$(foo)`) are converted to CSS custom properties:

```css
/* Input */
color: $(myColor);

/* Output */
color: var(--var-19ja411);
```

The variable name `--var-19ja411` is a hash of the original path:
```reason
let variable_to_css_var_name = path => {
  let original_path = String.concat(".", path);
  let hash = Murmur2.default(original_path);
  Printf.sprintf("var-%s", hash);
};
```

#### 3.3. Type Path Extraction (`get_interpolation_types`)

For each interpolation, the system determines the correct `toString` function by:

1. Rendering the value to a string
2. Calling `Css_grammar.Parser.get_interpolation_types(~name=property_name, value_string)`
3. The grammar parser extracts type information for each interpolation position

```reason
let interpolation_types =
  Css_grammar.Parser.get_interpolation_types(
    ~name=property_name,
    value_string,
  );
```

The grammar system uses `extract_interpolations` functions generated by `css-grammar/ppx/Generate.re` to traverse the parsed value and associate each interpolation with its type context.

**Example: Partial interpolation in `margin`**
```reason
/* Input */
margin: 8px $(right) $(bottom) $(left);

/* Generated */
CSS.make("css-1641h1j", [
  ("--var-j35jbq", CSS.Types.Length.toString(right)),
  ("--var-15kzvoi", CSS.Types.Length.toString(bottom)),
  ("--var-oyh7mz", CSS.Types.Length.toString(left)),
])
```

**Example: Partial interpolation in `box-shadow`**
```reason
/* Input */
box-shadow: 0 1px 0 0 $(myColor);

/* Generated - color interpolation gets Color type */
CSS.make("css-abc123", [
  ("--var-xyz789", CSS.Types.Color.toString(myColor)),
])
```

#### 3.4. Selector Transformation (`Styled_ppx_css_parser.Transform`)

Nested selectors and media queries are unnested and prefixed with the generated className:

```css
/* Input */
.lola { display: flex; }

/* Output */
.css-1lr2y8 .lola { display: flex; }
```

Bare declarations are wrapped with the className:
```reason
let wrapped = Style_rule({
  prelude: ([(CompoundSelector({
    type_selector: None,
    subclass_selectors: [Class(className)],
    pseudo_selectors: [],
  }), loc)], loc),
  block: ([Declaration(decl)], loc),
  loc,
});
```

### Stage 4: Code Generation (`Css_runtime.render_make_call`)

The PPX generates a call to `CSS.make`:

```reason
CSS.make(
  "css-17vxl0k css-3tpy8b",  /* space-separated atomic classNames */
  [
    ("--var-19ja411", CSS.Types.Color.toString(myColor)),
  ]
)
```

Implementation in `Css_runtime.re`:
```reason
let render_make_call = (~loc, ~classNames, ~dynamic_vars) => {
  let className_string = String.concat(" ", classNames);
  let className_expr = /* ... */;

  let var_list = dynamic_vars |> List.map(((var_name, original_path, type_path)) => {
    let field_name = "--" ++ var_name;
    let var_value = render_variable(~loc, String.split_on_char('.', original_path));

    /* Handle different type_path cases */
    let field_value =
      if (type_path == "selector" || type_path == "media-query") {
        /* Use fst() to extract className from cx2 tuple result */
        [%expr fst([%e var_value])];
      } else if (String.sub(type_path, 0, 10) == "Css_types.") {
        /* Use the specific module's toString */
        Property_to_types.make_to_string_call(~loc, module_name, var_value);
      } else {
        /* Fall back to property-name-based lookup */
        Property_to_types.get_to_string_for_property(~loc, type_path, var_value);
      };
    /* ... */
  });

  [%expr CSS.make([%e className_expr], [%e list_expr])];
};
```

### Stage 5: CSS Collection (`Css_file.Buffer`)

During PPX execution, all CSS rules are accumulated in `Css_file.Buffer`:

```reason
module Buffer = {
  type rule = (string, string);
  let accumulated_rules: ref(list(rule)) = ref([]);
  let global_rules: ref(list(rule)) = ref([]);

  let add_rule = (className: string, cssText: string) => {
    let already_exists = List.exists(
      ((existingClass, _)) => existingClass == className,
      accumulated_rules^,
    );
    if (!already_exists) {
      accumulated_rules := [(className, cssText), ...accumulated_rules^];
    };
  };
  /* ... */
};
```

The buffer deduplicates by className, so identical declarations across files produce only one CSS rule.

### Stage 6: Attribute Emission (`ppx.re`)

After processing all extensions, the PPX emits a `[@css ...]` attribute at the top of the file:

```reason
let impl = (_ctx, str) => {
  let loc = Ppxlib.Location.none;
  switch (Css_file.get()) {
  | "" => str
  | css => [[%stri [@css [%e Builder.estring(~loc, css)]]], ...str]
  };
};
```

This produces:

```reason
[@css ".css-17vxl0k { display: flex; }\n.css-3tpy8b { color: var(--var-19ja411); }\n"]
/* ... rest of file ... */
```

### Stage 7: CSS Extraction (`styled-ppx.generate`)

A separate binary (`packages/generate/generate.ml`) reads compiled `.ml` files and extracts CSS:

```bash
styled-ppx.generate output.ml > styles.css
```

It scans for `[@@@css ...]` attributes and concatenates all CSS:

```ocaml
let of_structure ~verbose ~filename structure stylesheet =
  List.fold_left
    (fun stylesheet item ->
      match item with
      | [%stri [@@@css [%e? value]]] ->
        (match get_string value with
        | Some v -> String_map.add filename v stylesheet
        | None -> stylesheet)
      | _ -> stylesheet)
    stylesheet structure
```

Output:
```css
/* This file is generated by styled-ppx, do not edit manually */
.css-17vxl0k { display: flex; }
.css-3tpy8b { color: var(--var-19ja411); }
```

## Runtime Behavior

### CSS.make (`packages/runtime/native/CSS.ml`)

```ocaml
type styles = string * ReactDOM.Style.t

let make className vars : styles =
  let style =
    List.fold_left
      (fun style (key, value) ->
        ReactDOM.Style.unsafeAddProp style key value)
      (ReactDOM.Style.make ()) vars
  in
  className, style
```

Returns a tuple of:
- `className`: The atomic class names to apply
- `style`: A ReactDOM style object with CSS custom properties

### CSS.merge

```ocaml
let merge (styles1 : styles) (styles2 : styles) : styles =
  let className = Printf.sprintf "%s %s" (fst styles1) (fst styles2) in
  let style = ReactDOM.Style.combine (snd styles1) (snd styles2) in
  String.trim className, style
```

### Usage in JSX

```reason
let css = color => [%cx2 "display: flex; color: $(color)"];

/* Expanded by styles prop rewriter */
<div className={fst(css(CSS.red))} style={snd(css(CSS.red))} />
```

The `styles` prop is a convenience that expands to both `className` and `style`.

## Type Safety

### Property-to-Module Mapping (`Property_to_types.re`)

Maps CSS properties to their `Css_types` modules:

```reason
let property_to_module_mapping = [
  ("color", "Color"),
  ("background-color", "Color"),
  ("width", "Length"),
  ("margin", "Length"),
  ("flex-basis", "LengthPercentage"),
  ("box-shadow", "BoxShadow"),
  ("text-shadow", "TextShadow"),
  /* ... */
];
```

The lookup also checks the grammar's `runtime_module_path`:
```reason
let property_to_module = property_name => {
  switch (Css_grammar.Parser.find_property(property_name)) {
  | Some(Css_grammar.Parser.Pack_rule({runtime_module_path, _})) =>
    switch (runtime_module_path) {
    | Some(path) => /* extract module name from "Css_types.Color" */
    | None => /* fallback to mapping */
    }
  | None => /* fallback to mapping */
  };
};
```

### Css_types Module (`packages/runtime/native/shared/Css_types.ml`)

Each type module provides a `toString` function:

```ocaml
module Color = struct
  type t = [ `hex of string | `rgb of int * int * int | ... ]

  let toString x = match x with
    | `hex s -> "#" ^ s
    | `rgb (r, g, b) -> Printf.sprintf "rgb(%d, %d, %d)" r g b
    | ...
end

module Length = struct
  type t = [ `px of int | `em of float | `rem of float | ... ]

  let toString x = match x with
    | `px n -> string_of_int n ^ "px"
    | `em n -> Float.to_string n ^ "em"
    | ...
end
```

### Grammar-Based Type Extraction (`css-grammar/ppx/Generate.re`)

The grammar PPX generates `extract_interpolations` functions that traverse parsed values and return `(variable_name, type_path)` pairs:

```reason
/* For a property like box-shadow: <shadow>#
   where <shadow> = <length>{2,4} <color>? */

let extract_interpolations = (value) => {
  /* Traverses the parsed value structure */
  /* When it finds an interpolation, uses the sibling type context */
  /* e.g., interpolation in color position gets "Css_types.Color" */
};
```

Special handling exists for complex properties like `transition`:
```ocaml
let extract_interpolation_from_extended_time (et : extended_time) =
  match et with
  | `Interpolation parts -> [ String.concat "." parts, "Css_types.Time" ]
  | _ -> []
```

## Related Extensions

### `[%keyframe2]`

Similar extraction for keyframes:

```reason
let fadeIn = [%keyframe2 {|
  from { opacity: 0; }
  to { opacity: 1; }
|}];
```

Becomes:

```reason
CSS.Types.AnimationName.make("keyframe-85bkd1")
```

And adds to the CSS buffer:
```css
@keyframes keyframe-85bkd1 { from { opacity: 0; } to { opacity: 1; } }
```

Implementation in `ppx.re`:
```reason
let keyframe2_extension = Ppxlib.Extension.declare("keyframe2", ..., (~loc, ~path, payload) => {
  /* ... */
  let keyframe_name = Css_file.push_keyframe(declarations);
  [%expr CSS.Types.AnimationName.make([%e Builder.estring(~loc, keyframe_name)])];
});
```

### `[%styled.global2]`

Global styles without className prefixing:

```reason
[%styled.global2 {|
  body { margin: 0; }
  * { box-sizing: border-box; }
|}];
```

Implementation:
```reason
Css_file.push_global(rule_list);
Builder.eunit(~loc=stringLoc);
```

The `push_global` function adds rules to a separate `global_rules` buffer that outputs first in the final CSS.

### `[%styled2.div]`

Styled component variant that uses `[%cx2]` internally:

```reason
module Button = [%styled2.div "display: flex; color: $(color)"];
```

Generates a component that:
1. Uses `fst(styles)` for className
2. Uses `snd(styles)` for inline style (CSS custom properties)

## Build Integration

Typical build setup:

1. **PPX processing**: `dune` runs `styled-ppx` on source files
2. **CSS extraction**: Post-build step runs `styled-ppx.generate *.ml -o styles.css`
3. **CSS inclusion**: Bundle `styles.css` with your application

```makefile
build:
	dune build
	styled-ppx.generate _build/default/**/*.pp.ml -o _build/styles.css
```

The generate binary supports:
- `-o` / `--output`: Output file (default: stdout)
- `-v` / `--verbose`: Verbose logging
- Reading from `.pp.ml` (preprocessed) or `.ml` files

## Minification

When `Settings.Get.minify()` returns `true`:
- CSS output uses `Styled_ppx_css_parser.Minify.rule` instead of `Render.rule`
- No newlines between rules
- Minimal whitespace

```reason
let (render_rule, render_declaration) =
  if (Settings.Get.minify()) {
    (Styled_ppx_css_parser.Minify.rule, Styled_ppx_css_parser.Minify.declaration);
  } else {
    (Styled_ppx_css_parser.Render.rule, Styled_ppx_css_parser.Render.declaration);
  };
```

## Comparison: cx vs cx2

| Aspect | `[%cx]` | `[%cx2]` |
|--------|---------|----------|
| CSS Generation | Runtime (emotion.sh) | Compile-time extraction |
| Interpolation | Direct value substitution | CSS custom properties + toString |
| Output | `CSS.style([| ... |])` | `CSS.make(classNames, vars)` |
| CSS File | None (injected at runtime) | Extracted `.css` file |
| Type Safety | Full (OCaml inference) | Full (explicit toString) |
| Runtime Overhead | CSS parsing + injection | Only style prop assignment |
| Deduplication | Runtime hash-based | Compile-time className-based |

## Key Files Reference

| File | Purpose |
|------|---------|
| `packages/ppx/src/ppx.re` | Main PPX entry, extension declarations |
| `packages/ppx/src/Css_file.re` | Buffer, atomization, variable transformation |
| `packages/ppx/src/Css_runtime.re` | Code generation for `CSS.make` calls |
| `packages/ppx/src/Property_to_types.re` | Property-to-module mapping |
| `packages/css-grammar/lib/Parser.ml` | Grammar rules, `get_interpolation_types` |
| `packages/css-grammar/ppx/Generate.re` | Generates `extract_interpolations` functions |
| `packages/css-parser/lib/Ast.re` | CSS AST types |
| `packages/runtime/native/CSS.ml` | Runtime `make`, `merge`, `style_tag` |
| `packages/runtime/native/shared/Css_types.ml` | Type modules with `toString` |
| `packages/generate/generate.ml` | CSS extraction binary |
