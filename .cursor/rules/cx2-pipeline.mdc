---
alwaysApply: false
---
# cx2 Pipeline - Static CSS Extraction

This document explains how `[%cx2]` worksâ€”the statically extracted CSS path. Unlike `[%cx]` which generates runtime CSS-in-JS code, `[%cx2]` extracts CSS at compile-time into a separate `.css` file with zero runtime CSS generation overhead.

## Overview

```reason
let css = color => [%cx2 "display: flex; color: $(color)"];
```

Gets transformed into:

```reason
[@css ".css-17vxl0k { display: flex; }\n.css-3tpy8b { color: var(--var-19ja411); }\n"]
let css = color => CSS.make(
  "css-17vxl0k css-3tpy8b",
  [("--var-19ja411", CSS.Types.Color.toString(color))]
);
```

The key differences from `[%cx]`:
1. **Atomic CSS** - Each declaration gets its own className (e.g., `css-17vxl0k` for `display: flex`)
2. **CSS Custom Properties** - Interpolations become `var(--var-xxxx)` references
3. **Static Extraction** - CSS is collected into a `[@css ...]` attribute, later extracted to a `.css` file
4. **Runtime Type Coercion** - `CSS.Types.X.toString` converts typed values to strings at runtime

## Pipeline Stages

### Stage 1: Parsing

Same as `[%cx]` - the CSS string is parsed by `Styled_ppx_css_parser.Driver.parse_declaration_list`.

```reason
[%cx2 "display: flex; color: $(myColor)"]
```

Produces an AST representing:
- Declaration: `display: flex`
- Declaration: `color: $(myColor)` (with `myColor` as a `Variable` node)

### Stage 2: Type Checking

Before extraction, `[%cx2]` validates all properties against the CSS spec using `type_check_rule_list`:

```reason
let validations = type_check_rule_list(rule_list);
switch (get_errors(validations)) {
| [] => /* proceed with extraction */
| errors => /* report type errors */
}
```

This ensures invalid CSS like `display: banana` is caught at compile-time.

### Stage 3: CSS Transformation (`Css_file.push`)

The parsed AST goes through `Css_file.push` which:

#### 3.1. Atomization

Each declaration becomes its own atomic rule with a content-hashed className:

```css
/* Input */
display: flex; color: red;

/* Output - two separate rules */
.css-17vxl0k { display: flex; }
.css-3tpy8b { color: red; }
```

The className is generated via `Murmur2.default(css_content)` ensuring identical declarations share the same className across the codebase.

#### 3.2. Variable Transformation

Interpolations (`$(foo)`) are converted to CSS custom properties:

```css
/* Input */
color: $(myColor);

/* Output */
color: var(--var-19ja411);
```

The variable name `--var-19ja411` is a hash of the original path (`myColor`).

#### 3.3. Type Path Extraction

For each interpolation, the system determines the correct `toString` function by:

1. Parsing the value with the property's grammar (e.g., `Parser.Property_color.rule`)
2. Calling `extract_interpolations` on the parsed value
3. Getting the type path (e.g., `Css_types.Color`) for each interpolated variable

This is handled by `Css_grammar.Parser.get_interpolation_types(~name=property_name, value_string)`.

#### 3.4. Selector Transformation

Nested selectors and media queries are unnested and prefixed with the generated className:

```css
/* Input */
.lola { display: flex; }

/* Output */
.css-1lr2y8 .lola { display: flex; }
```

### Stage 4: Code Generation (`Css_runtime.render_make_call`)

The PPX generates a call to `CSS.make`:

```reason
CSS.make(
  "css-17vxl0k css-3tpy8b",  /* space-separated atomic classNames */
  [
    ("--var-19ja411", CSS.Types.Color.toString(myColor)),
  ]
)
```

Where:
- First argument: concatenated atomic classNames
- Second argument: list of `(css-var-name, toString(value))` pairs

### Stage 5: CSS Collection (`Css_file.Buffer`)

During PPX execution, all CSS rules are accumulated in `Css_file.Buffer`:

```reason
Buffer.add_rule(className, cssText);
```

The buffer deduplicates by className, so identical declarations across files produce only one CSS rule.

### Stage 6: Attribute Emission

After processing all extensions, the PPX emits a `[@css ...]` attribute at the top of the file:

```reason
let impl = (_ctx, str) => {
  switch (Css_file.get()) {
  | "" => str
  | css => [[%stri [@css [%e Builder.estring(~loc, css)]]], ...str]
  };
};
```

This produces:

```reason
[@css ".css-17vxl0k { display: flex; }\n.css-3tpy8b { color: var(--var-19ja411); }\n"]
/* ... rest of file ... */
```

### Stage 7: CSS Extraction (`styled-ppx.generate`)

A separate binary reads compiled `.ml` files and extracts CSS:

```bash
styled-ppx.generate output.ml > styles.css
```

It scans for `[@@@css ...]` attributes and concatenates all CSS:

```ocaml
match item with
| [%stri [@@@css [%e? value]]] ->
  (* Extract string and add to stylesheet *)
```

Output:
```css
/* This file is generated by styled-ppx, do not edit manually */
.css-17vxl0k { display: flex; }
.css-3tpy8b { color: var(--var-19ja411); }
```

## Runtime Behavior

### CSS.make

```ocaml
type styles = string * ReactDOM.Style.t

let make className vars : styles =
  let style =
    List.fold_left
      (fun style (key, value) ->
        ReactDOM.Style.unsafeAddProp style key value)
      (ReactDOM.Style.make ()) vars
  in
  className, style
```

Returns a tuple of:
- `className`: The atomic class names to apply
- `style`: A ReactDOM style object with CSS custom properties

### Usage in JSX

```reason
let css = color => [%cx2 "display: flex; color: $(color)"];

/* Expanded by styles prop rewriter */
<div className={fst(css(CSS.red))} style={snd(css(CSS.red))} />
```

The `styles` prop is a convenience that expands to both `className` and `style`.

## Type Safety

### Property-to-Module Mapping (`Property_to_types.re`)

Maps CSS properties to their `Css_types` modules:

```reason
let property_to_module_mapping = [
  ("color", "Color"),
  ("background-color", "Color"),
  ("width", "Length"),
  ("margin", "Length"),
  ("flex-basis", "LengthPercentage"),
  /* ... */
];
```

### Partial Interpolation

When interpolating part of a value (not the entire value), the system uses the grammar's `extract_interpolations` to determine the correct type:

```reason
/* Input */
margin: 8px $(right) $(bottom) $(left);

/* Generated */
CSS.make("css-1641h1j", [
  ("--var-j35jbq", CSS.Types.Margin.toString(right)),
  ("--var-15kzvoi", CSS.Types.Margin.toString(bottom)),
  ("--var-oyh7mz", CSS.Types.Margin.toString(left)),
])
```

Each interpolation gets the correct `Margin.toString` because the grammar knows the `<length-percentage>` positions in the margin shorthand.

## Related Extensions

### `[%keyframe2]`

Similar extraction for keyframes:

```reason
let fadeIn = [%keyframe2 {|
  from { opacity: 0; }
  to { opacity: 1; }
|}];
```

Becomes:

```reason
let fadeIn = `KeyframesName("keyframe-85bkd1");
```

And adds to the CSS buffer:
```css
@keyframes keyframe-85bkd1 { from { opacity: 0; } to { opacity: 1; } }
```

### `[%styled.global2]`

Global styles without className prefixing:

```reason
[%styled.global2 {|
  body { margin: 0; }
  * { box-sizing: border-box; }
|}];
```

Outputs directly to CSS:
```css
body { margin: 0; }
* { box-sizing: border-box; }
```

## Build Integration

Typical build setup:

1. **PPX processing**: `dune` runs `styled-ppx` on source files
2. **CSS extraction**: Post-build step runs `styled-ppx.generate *.ml -o styles.css`
3. **CSS inclusion**: Bundle `styles.css` with your application

```makefile
build:
	dune build
	styled-ppx.generate _build/default/**/*.pp.ml -o _build/styles.css
```

## Minification

When `Settings.Get.minify()` returns `true`:
- CSS output uses `Styled_ppx_css_parser.Minify.rule` instead of `Render.rule`
- No newlines between rules
- Minimal whitespace

## Comparison: cx vs cx2

| Aspect | `[%cx]` | `[%cx2]` |
|--------|---------|----------|
| CSS Generation | Runtime (emotion.sh) | Compile-time extraction |
| Interpolation | Direct value substitution | CSS custom properties + toString |
| Output | `CSS.style([| ... |])` | `CSS.make(classNames, vars)` |
| CSS File | None (injected at runtime) | Extracted `.css` file |
| Type Safety | Full (OCaml inference) | Full (explicit toString) |
| Runtime Overhead | CSS parsing + injection | Only style prop assignment |
