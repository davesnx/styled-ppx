module Buffer = {
  /* In-memory buffer to accumulate CSS rules during compilation */
  /* Using a list of (className, css) pairs to track unique rules */
  let css_rules: ref(list((string, string))) = ref([]);

  let add_rule = (className: string, css: string) => {
    /* Only add the rule if it doesn't already exist */
    let exists =
      List.exists(
        ((existingClass, _)) => existingClass == className,
        css_rules^,
      );
    if (!exists) {
      css_rules := [(className, css), ...css_rules^];
    };
  };

  let get_css_content = () => {
    let rules =
      List.rev(css_rules^)
      |> List.map(((className, css)) =>
           Printf.sprintf(".%s {\n%s\n}", className, css)
         );
    String.concat("\n", rules);
  };

  let clear = () => {
    css_rules := [];
  };
};

type write_result =
  | Unchanged
  | Updated
  | Created;

let read_file_safe = filename =>
  try({
    let ic = open_in(filename);
    let content = really_input_string(ic, in_channel_length(ic));
    close_in(ic);
    Some(content);
  }) {
  | Sys_error(_) => None
  };

let write_file = (~filename: string, content: string) => {
  let result =
    switch (read_file_safe(filename)) {
    | Some(existing_content) when existing_content == content =>
      Log.debug("File content unchanged, skipping write");
      Unchanged;
    | Some(_) =>
      Log.debug("File content changed, updating file");
      let oc = open_out(filename);
      output_string(oc, content);
      close_out(oc);
      Updated;
    | None =>
      Log.debug("File doesn't exist");
      let oc = open_out(filename);
      output_string(oc, content);
      close_out(oc);
      Created;
    };

  result;
};

let get_output_path = () => {
  /* For now, write to _build directory if it exists, otherwise current directory */
  let build_dir = "_build";
  let css_dir =
    if (Sys.file_exists(build_dir) && Sys.is_directory(build_dir)) {
      Filename.concat(build_dir, "styled-ppx-css");
    } else {
      "styled-ppx-css";
    };

  if (!Sys.file_exists(css_dir)) {
    Unix.mkdir(css_dir, 0o755);
  };

  let output_path = Filename.concat(css_dir, "styles.css");
  Log.debug(Printf.sprintf("CSS output path: %s", output_path));
  output_path;
};

let extract_static_css = (~loc: Ppxlib.Location.t, styles: string) => {
  let className = {
    /* TODO: Check if styles are empty */
    let hash = Murmur2.default(styles);
    Printf.sprintf("css-%s", hash);
  };

  let content =
    switch (Settings.Get.debug()) {
    | true =>
      Printf.sprintf(
        "  /* Generated from [%%cx] in %s at line %d */%s",
        loc.loc_start.pos_fname,
        loc.loc_start.pos_lnum,
        styles,
      )
    | _false => styles
    };

  Buffer.add_rule(className, content);

  className;
};

let finalize_css_generation = () => {
  let file_content = Buffer.get_css_content();
  if (String.length(file_content) > 0) {
    let filename = get_output_path();

    let content =
      Printf.sprintf(
        "/* Generated by styled-ppx */\n/* This file is auto-generated, do not edit manually */\n\n%s\n",
        file_content,
      );

    switch (write_file(~filename, content)) {
    | Created =>
      Log.debug(Printf.sprintf("CSS file created at: %s", filename))
    | Updated =>
      Log.debug(Printf.sprintf("CSS file updated at: %s", filename))
    | Unchanged => ()
    };
  } else {
    Log.debug("No CSS content to generate");
  };
  Buffer.clear();
};

Stdlib.at_exit(() => finalize_css_generation());
