module Buffer = {
  /* In-memory buffer to accumulate CSS rules during compilation */
  /* Using a list of (className, css) pairs to track unique rules */
  let css_rules: ref(list((string, string))) = ref([]);

  let add_rule = (className: string, css: string) => {
    /* Only add the rule if it doesn't already exist */
    let exists =
      List.exists(
        ((existingClass, _)) => existingClass == className,
        css_rules^,
      );
    if (!exists) {
      css_rules := [(className, css), ...css_rules^];
    };
  };

  let get_css_content = () => {
    let rules =
      List.rev(css_rules^)
      |> List.map(((className, css)) =>
           Printf.sprintf(".%s {\n%s\n}", className, css)
         );
    String.concat("\n", rules);
  };

  let clear = () => {
    css_rules := [];
  };
};

type write_result =
  | Unchanged
  | Updated
  | Created;

let read_file_safe = filename =>
  try({
    let ic = open_in(filename);
    let content = really_input_string(ic, in_channel_length(ic));
    close_in(ic);
    Some(content);
  }) {
  | Sys_error(_) => None
  };

let write_file = (~filename: string, content: string) => {
  let result =
    switch (read_file_safe(filename)) {
    | Some(existing_content) when existing_content == content =>
      Log.debug("File content unchanged, skipping write");
      Unchanged;
    | Some(_) =>
      Log.debug("File content changed, updating file");
      let oc = open_out(filename);
      output_string(oc, content);
      close_out(oc);
      Updated;
    | None =>
      Log.debug("File doesn't exist");
      let oc = open_out(filename);
      output_string(oc, content);
      close_out(oc);
      Created;
    };

  result;
};

/*
 * Determines where CSS files should be generated.
 *
 * The output directory MUST be explicitly specified via the --output flag.
 * There is no automatic detection or fallback behavior.
 *
 * Usage:
 * - Pass --output=/path/to/output when invoking the ppx
 */
let get_output_path = () => {
  let css_dir =
    switch (Settings.Get.output()) {
    | None =>
      /* No output path configured - this is an error */
      raise(
        Failure(
          "styled-ppx: CSS output directory must be specified using --output flag. Example: --output=./styles",
        ),
      )
    | Some(configured_path) =>
      /* Use the explicitly configured path */
      configured_path
    };

  /* Ensure the directory exists */
  if (!Sys.file_exists(css_dir)) {
    /* Create parent directories if needed */
    let rec create_parent_dirs = path => {
      let parent = Filename.dirname(path);
      if (parent != path && parent != "." && !Sys.file_exists(parent)) {
        create_parent_dirs(parent);
        Unix.mkdir(parent, 0o755);
      };
    };

    create_parent_dirs(css_dir);
    if (!Sys.file_exists(css_dir)) {
      Unix.mkdir(css_dir, 0o755);
    };
  };

  let output_path = Filename.concat(css_dir, "styles.css");
  Log.debug(Printf.sprintf("CSS output path: %s", output_path));
  output_path;
};

let add_css = (~className: string, ~css: string) => {
  Buffer.add_rule(className, css);
};

let finalize_css_generation = () => {
  let file_content = Buffer.get_css_content();
  if (String.length(file_content) > 0) {
    let filename = get_output_path();

    let content =
      Printf.sprintf(
        "/* This file is auto-generated by styled-ppx, do not edit manually */\n\n%s\n",
        file_content,
      );

    switch (write_file(~filename, content)) {
    | Created =>
      Log.debug(Printf.sprintf("CSS file created at: %s", filename))
    | Updated =>
      Log.debug(Printf.sprintf("CSS file updated at: %s", filename))
    | Unchanged => ()
    };
  } else {
    Log.debug("No CSS content to generate");
  };
  Buffer.clear();
};

Stdlib.at_exit(() => finalize_css_generation());
