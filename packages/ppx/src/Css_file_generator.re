module Buffer = {
  /* In-memory buffer to accumulate CSS rules during compilation */
  let css_rules: ref(list(string)) = ref([]);

  let add_rule = (className: string, css: string) => {
    let rule = Printf.sprintf(".%s {\n%s\n}", className, css);
    css_rules := [rule, ...css_rules^];
  };

  let get_css_content = () => {
    let rules = List.rev(css_rules^);
    String.concat("\n\n", rules);
  };

  let clear = () => {
    css_rules := [];
  };
};

let generate_class_name = (~loc: Ppxlib.Location.t, ~valueName: string) => {
  /* For now, generate a simple hash based on location and name */
  let hash =
    Printf.sprintf(
      "%s_%d_%d",
      valueName,
      loc.loc_start.pos_lnum,
      loc.loc_start.pos_cnum,
    )
    |> Digest.string
    |> Digest.to_hex
    |> String.sub(_, 0, 8);
  Printf.sprintf("css_%s", hash);
};

let read_file_safe = filename =>
  try({
    let ic = open_in(filename);
    let content = really_input_string(ic, in_channel_length(ic));
    close_in(ic);
    Some(content);
  }) {
  | Sys_error(_) => None
  };

let write_css_file = (~filename: string, ~content: string) => {
  /* Check if file exists and has the same content */
  let should_write =
    switch (read_file_safe(filename)) {
    | Some(existing_content) when existing_content == content =>
      /* Content hasn't changed, skip writing */
      false
    | _ =>
      /* File doesn't exist or content is different */
      true
    };

  if (should_write) {
    let oc = open_out(filename);
    output_string(oc, content);
    close_out(oc);
    true; /* File was written */
  } else {
    false; /* File was not written (content unchanged) */
  };
};

let get_output_path = () => {
  /* For now, write to _build directory if it exists, otherwise current directory */
  let build_dir = "_build";
  let css_dir =
    if (Sys.file_exists(build_dir) && Sys.is_directory(build_dir)) {
      Filename.concat(build_dir, "styled-ppx-css");
    } else {
      "styled-ppx-css";
    };

  /* Create directory if it doesn't exist */
  if (!Sys.file_exists(css_dir)) {
    Unix.mkdir(css_dir, 0o755);
  };

  Filename.concat(css_dir, "styles.css");
};

let extract_static_css =
    (~loc: Ppxlib.Location.t, ~valueName: string, ~styles: string) => {
  /* Generate a unique class name */
  let className = generate_class_name(~loc, ~valueName);

  /* For now, add fixture CSS content (in the future, we'll parse and use the actual styles) */
  let fixture_css =
    Printf.sprintf(
      "  /* Generated from [%%cx] at %s */%s",
      valueName,
      styles,
      /* String.escaped(styles), */
    );

  /* Add the rule to our buffer */
  Buffer.add_rule(className, fixture_css);

  /* Return the className to be used in the transformed code */
  className;
};

let finalize_css_generation = () => {
  let content = Buffer.get_css_content();
  if (String.length(content) > 0) {
    let output_path = get_output_path();

    /* Add CSS header */
    let final_content =
      Printf.sprintf(
        "/* Generated by styled-ppx */\n/* This file is auto-generated, do not edit manually */\n\n%s\n",
        content,
      );

    let was_written =
      write_css_file(~filename=output_path, ~content=final_content);
    if (was_written) {
      Printf.printf("CSS file generated at: %s\n", output_path);
    } else {
      Printf.printf("CSS file unchanged: %s\n", output_path);
    };
  };
  Buffer.clear();
};

/* Register a hook to write CSS file at the end of compilation */
let () = {
  at_exit(() => {finalize_css_generation()});
};
